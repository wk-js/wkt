"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const api_1 = require("../api");
const function_1 = require("lol/utils/function");
const asset_pipeline_1 = require("asset-pipeline/js/asset-pipeline");
const merge_tool_1 = require("asset-pipeline/js/experimental/merge-tool");
const path_1 = require("path");
const when_1 = require("when");
const fs_1 = require("asset-pipeline/js/utils/fs");
const object_1 = require("lol/utils/object");
const chunk_stack_1 = require("./chunk_stack");
class FileAPI extends api_1.API {
    /**
     * Data shared between all bunldes
     */
    get data() {
        return this.shared_store('template:data') ?
            this.shared_store('template:data') :
            this.shared_store('template:data', {});
    }
    /**
     * Get an array of every asset-pipeline generated by bundles
     */
    get assets() {
        if (!this.shared_store('assets')) {
            return this.shared_store('assets', []);
        }
        return this.shared_store('assets');
    }
    /**
     * Chunk shared between all bunldes
     */
    get chunk_stack() {
        if (!this.shared_store('assets:chunk_stack')) {
            return this.shared_store('assets:chunk_stack', new chunk_stack_1.ChunkStack);
        }
        return this.shared_store('assets:chunk_stack');
    }
    /**
     * Get the asset pipeline of the active bundle
     */
    get asset() {
        if (this.store('file:asset')) {
            return this.store('file:asset');
        }
        const asset = new asset_pipeline_1.AssetPipeline;
        this.store('file:asset', asset);
        this.assets.push(asset);
        return asset;
    }
    init() {
        function_1.bind(this, '_copyAndRender', 'bundle_copy', 'bundle_render');
        this.boilerplate.root.stack.after('bundle', 'render:template', this._copyAndRender);
    }
    bundle() {
        this.asset.load_path = path_1.dirname(this.boilerplate.input);
        this.asset.dst_path = this.boilerplate.output;
        this.asset.save_manifest = false;
        return this.asset.resolve(true);
    }
    _copyAndRender() {
        return this.bundle_copy()
            .then(this.bundle_render);
    }
    /**
     * Copy files
     */
    bundle_copy() {
        return when_1.reduce(this.assets, (reduction, asset) => {
            const ios = Object.keys(asset.manifest.manifest.assets).map((key) => {
                return [
                    asset.fromLoadPath(key),
                    asset.fromDstPath(asset.getPath(key))
                ];
            });
            return when_1.all(ios.map((io) => {
                return fs_1.copy(path_1.relative(process.cwd(), io[0]), path_1.relative(process.cwd(), io[1]));
            }));
        }, null);
    }
    /**
     * Render files and edit them
     */
    bundle_render() {
        const assets = merge_tool_1.MergeTool.fetch_assets.apply(null, this.assets);
        return when_1.reduce(this.assets, (reduction, asset) => {
            const options = asset.renderer.options || {};
            options.imports = object_1.merge(options.imports || {}, asset.data, this.data);
            const imports = options.imports;
            imports.chunk = (key) => {
                return this.chunk_stack.get(key) || '';
            };
            options.interpolate = options.interpolate || /{%=([\s\S]+?)%}/g;
            options.escape = options.escape || /{%-([\s\S]+?)%}/g;
            options.evaluate = options.evaluate || /{%([\s\S]+?)%}/g;
            asset.renderer.options = options;
            asset.manifest.manifest.assets = assets;
            return asset.renderer.render().then(function () {
                return asset.renderer.edit();
            });
        }, null);
    }
    helpers() {
        return {
            addFile: this.addFile,
            ignoreFile: this.ignoreFile,
            addDirectory: this.addDirectory,
            ignoreDirectory: this.ignoreDirectory,
            editFile: this.editFile,
            templateFile: this.templateFile,
            templateData: this.templateData,
            chunk: this.chunk
        };
    }
    addFile(glob, parameters) {
        this.asset.addFile(glob, parameters);
    }
    ignoreFile(glob) {
        this.asset.ignoreFile(glob);
    }
    addDirectory(glob, parameters) {
        this.asset.addDirectory(glob, parameters);
    }
    ignoreDirectory(glob) {
        this.asset.ignoreDirectory(glob);
    }
    templateFile(glob, template) {
        this.asset.addFile(glob, { glob: glob, template: template });
    }
    templateData(data, options) {
        if (options)
            this.asset.renderer.options = options;
        return object_1.merge(this.data, data);
    }
    editFile(glob, callback) {
        this.asset.addFile(glob, { glob: '', edit: callback });
    }
    chunk() {
        return this.chunk_stack;
    }
}
exports.FileAPI = FileAPI;
